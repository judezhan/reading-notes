## 3. 包
包是函数和数据的集合。用 **package** 关键字定义一个包。*文件名不需要与包名一致。包名的约定是使用小写字符。*Go 包可以由多个文件组成,但是使用相同的 package <name> 这一行。

名称以大写字母起始的是可导出的,可以在包的外部调用

在 Go 中,当函数的首字母大写的时候,函数会被从包中导出(在包外部可见,或者说 公有的)

概括来说

* 公有函数的名字以大写字母开头* 私有函数的名字以小写字母开头
> 这个规则同样适用于定义在包中的其他名字(新类型、全局变量)。注意,“大写” 的含 义并不仅限于 US ASCII,它被扩展到了所有大小写字母表(拉丁文、希腊文、斯拉夫 文、亚美尼亚文和埃及古文)。

### 标识符

* 像在其他语言中一样,Go 的命名是很重要的。在某些情况下,它们甚至有语义上的作 用:例如,在包外是否可见决定于首字母是不是大写。

* 当包导入(通过 import)时,包名成为了内容的入口。在 **import "bytes"**之后,导入包的可以调用函数 bytes.Buffer。任何使用这个包的人,可以使用同样 的名字访问到它的内容,因此这样的包名是好的:**短的、简洁的、好记的**。根据规则, 
    * 包名是小写的一个单词;
    * 不应当有下划线或混合大小写。
    
* 包名是导入的默认名称。可以通过在导入语句指定其他名称来覆盖默认名称:
    > import bar "bytes"
    
* 包名无需全局唯一;在少 有的冲突中,可以给导入的包选择另一个名字在局部使用。在任何时候,冲突都是很 少见的,因为导入的文件名会用来做判断,到底是哪个包使用了。

* 在 Go 中使用混合大小写 MixedCaps 或者 mixedCaps,而不是下划线区分含有多 个单词的名字。

### 常用的包

* fmt
	* 包 fmt 实现了格式化的 I/O 函数，这与 C 的 printf 和 scanf 类似。格式化短语 派生于 C 。
	
* io
	* 这个包提供了原始的 I/O 操作界面。它主要的任务是对 os 包这样的原始的 I/O 进行封装，增加一些其他相关，使其具有抽象功能用在公共的接口上。 
	
* bufio
	* 这个包实现了缓冲的 I/O。它封装于 io.Reader 和 io.Writer 对象，创建了另 一个对象(Reader 和 Writer)在提供缓冲的同时实现了一些文本 I/O 的功能。
	
* sort
	* sort 包提供了对数组和用户定义集合的原始的排序功能。
	
* strconv
	* strconv 包提供了将字符串转换成基本数据类型，或者从基本数据类型转换为字 符串的功能。
	
* os
	* os 包提供了与平台无关的操作系统功能接口。其设计是 Unix 形式的。
	
* sync
	* sync 包提供了基本的同步原语，例如互斥锁。
	
* flag
	* flag 包实现了命令行解析。
	
* encoding/json
	* encoding/json 包实现了编码与解码 RFC 4627 [2] 定义的 JSON 对象。
	
* html/template
	* 数据驱动的模板，用于生成文本输出，例如 HTML。
	
* net/http
	* net/http 实现了 HTTP 请求、响应和 URL 的解析，并且提供了可扩展的 HTTP 服 务和基本的 HTTP 客户端。
	
* unsafe
	* unsafe 包包含了 Go 程序中数据类型上所有不安全的操作。*通常无须使用这个。*
	
* reflect
	* reflect 包实现了运行时反射，允许程序通过抽象类型操作对象。通常用于处理静态类型 interface{} 的值，并且通过 Typeof 解析出其动态类型信息，通常会返回一个有接口类型 Type 的对象。
	
* os/exec
	* os/exec 包执行外部命令。
	
		
## 4. 进阶

Go 有指针。然而却没有指针运算，因此它们更象是引用而不是你所知道的来自于 C 的指针。指针非常有用。在 Go 中调用函数的时候，得记得变量是值传递的。因此，为 了修改一个传递入函数的值的效率和可能性，有了指针。

通过类型作为前缀来定义一个指针 ’*’ : var p *int。现在 p 是一个指向整数值的指针。 所有新定义的变量都被赋值为其类型的零值，而指针也一样。一个新定义的或者没有 任何指向的指针，有值 nil。在其他语言中，这经常被叫做空(NULL)指针，在 Go 中 就是 nil。让指针指向某些内容，可以使用取址操作符 (&)。

从指针种获取值，是通过在指针变量前加*来实现的。

指针没有运算，所以如果这样写:\*p++，它表示 (\*p)++:首先获取指 针指向的值，然后对这个值加一。

### 内存分配

* Go 同样也垃圾收集，也就是说无须担心内存分配和回收。

* Go 有两个内存分配原语，**new** 和 **make**。它们应用于不同的类型，做不同的工作。
	 * 内建函数 new 本质上说跟其他语言中的同名函数功能一样: new(T) 分配了**零值填充**的 T 类型的内存空间，**并且返回其地址**，一个 \*T 类型的值。用 Go 的术语说，*它返回了一个指针* ，指向新分配的类型 T 的零值。这意味着使用者可以用 new 创建一个数据结构的实例并且可以直接工作。记住这点非常重要。
	 * 内建函数 make(T, args) 与 new(T) 有着不同的功能。它只能创建 **slice**，**map** 和 **channel**，并且返回一个有初始值(**非零**)的 T 类型，而不是 \*T。本质来讲，导致这三个类型有所不同的原因是指向数据结构的引用在使用前必须被初始化。**务必记得 make 仅适用于 map，slice 和 channel，并且返回的不是指针。应当用 new 获 得特定的指针。**
	 
	 > new分配; make 初始化
	 
	 > new(T) 返回*T，指向一个零值T
	 
	 > make(T) 返回初始化后的T
	 
### 定义自己的类型

* Go 允许定义新的类型，通过关键字 type 实现。

	> type foo int 创建了一个新的类型 foo 作用跟 int 一样。创建更加复杂的类型需要用到 struct 关键字。
